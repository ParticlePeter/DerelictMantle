/*

Boost Software License - Version 1.0 - August 17th,2003

Permission is hereby granted,free of charge,to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use,reproduce,display,distribute,
execute,and transmit the Software,and to prepare derivative works of the
Software,and to permit third-parties to whom the Software is furnished to
do so,all subject to the following:

The copyright notices in the Software and this entire statement,including
the above license grant,this restriction and the following disclaimer,
must be included in all copies of the Software,in whole or in part,and
all derivative works of the Software,unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR
IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE,TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY,WHETHER IN CONTRACT,TORT OR OTHERWISE,
ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

module derelict.mantle.mantle_wsi;

import derelict.mantle.types;

/* WSI Extension Object Handles */
alias GR_WSI_WIN_DISPLAY                     = uint;

/* WSI Extension Constants */
const int GR_MAX_DEVICE_NAME_LEN             = 255;   // Guess
const int GR_MAX_GAMMA_RAMP_CONTROL_POINTS   = 255;   // Guess

/* WSI Extension Enumerations */
alias GR_WSI_WIN_IMAGE_STATE                 = uint;
alias GR_WSI_WIN_PRESENT_MODE                = uint;

/* WSI Extension Flags */
alias GR_WSI_WIN_IMAGE_CREATE_FLAGS          = uint;
alias GR_WSI_WIN_PRESENT_FLAGS               = uint;

/* WSI Extension Enumerations */
enum /*GR_WSI_WIN_IMAGE_STATE*/  {
   GR_WSI_WIN_IMAGE_STATE_PRESENT_WINDOWED   = 0x00200000,
   GR_WSI_WIN_IMAGE_STATE_PRESENT_FULLSCREEN = 0x00200001,
}

enum /*GR_WSI_WIN_INFO_TYPE*/  {
   GR_WSI_WIN_INFO_TYPE_QUEUE_PROPERTIES             = 0x00206800,
   GR_WSI_WIN_INFO_TYPE_DISPLAY_PROPERTIES           = 0x00206801,
   GR_WSI_WIN_INFO_TYPE_GAMMA_RAMP_CAPABILITIES      = 0x00206802,
   GR_WSI_WIN_INFO_TYPE_DISPLAY_FREESYNC_SUPPORT     = 0x00206803,
   GR_WSI_WIN_INFO_TYPE_PRESENTABLE_IMAGE_PROPERTIES = 0x00206804,
   GR_WSI_WIN_INFO_TYPE_EXTENDED_DISPLAY_PROPERTIES  = 0x00206805,
}

enum /*GR_WSI_WIN_PRESENT_MODE*/  {
   GR_WSI_WIN_PRESENT_MODE_WINDOWED   = 0x00200200,
   GR_WSI_WIN_PRESENT_MODE_FULLSCREEN = 0x00200201,
}

enum /*GR_WSI_WIN_ROTATION_ANGLE*/  {
   GR_WSI_WIN_ROTATION_ANGLE_0   = 0x00200100,
   GR_WSI_WIN_ROTATION_ANGLE_90  = 0x00200101,
   GR_WSI_WIN_ROTATION_ANGLE_180 = 0x00200102,
   GR_WSI_WIN_ROTATION_ANGLE_270 = 0x00200103,
}

/* WSI Extension Flags */
enum /*GR_WSI_WIN_EXTENDED_DISPLAY_FLAGS*/  {
   GR_WSI_WIN_WINDOWED_VBLANK_WAIT  = 0x00000001,
   GR_WSI_WIN_WINDOWED_GET_SCANLINE = 0x00000002,
}

enum /*GR_WSI_WIN_IMAGE_CREATE_FLAGS*/  {
   GR_WSI_WIN_IMAGE_CREATE_FULLSCREEN_PRESENT = 0x00000001,
   GR_WSI_WIN_IMAGE_CREATE_STEREO             = 0x00000002,
}

enum /*GR_WSI_WIN_PRESENT_FLAGS*/  {
   GR_WSI_WIN_PRESENT_FULLSCREEN_DONOTWAIT = 0x00000001,
   GR_WSI_WIN_PRESENT_FULLSCREEN_STEREO    = 0x00000002,
}

enum /*GR_WSI_WIN_PRESENT_SUPPORT_FLAGS*/  {
   GR_WSI_WIN_FULLSCREEN_PRESENT_SUPPORTED = 0x00000001,
   GR_WSI_WIN_WINDOWED_PRESENT_SUPPORTED   = 0x00000002,
}

/* WSI Extension Structures */
struct GR_RGB_FLOAT  {
   GR_FLOAT red;
   GR_FLOAT green;
   GR_FLOAT blue;
}

struct GR_WSI_WIN_DISPLAY_MODE  {
   GR_EXTENT2D extent;
   GR_FORMAT   format;
   GR_UINT     refreshRate;
   GR_BOOL     stereo;
   GR_BOOL     crossDisplayPresent;
}

alias void * HMONITOR;
struct GR_WSI_WIN_DISPLAY_PROPERTIES  {
   HMONITOR hMonitor;
   GR_CHAR[ GR_MAX_DEVICE_NAME_LEN ]  displayName;
   GR_RECT  desktopCoordinates;
   GR_ENUM  rotation;
}

struct GR_WSI_WIN_EXTENDED_DISPLAY_PROPERTIES  {
   GR_FLAGS extendedProperties;
}

struct GR_WSI_WIN_GAMMA_RAMP  {
   GR_RGB_FLOAT  scale;
   GR_RGB_FLOAT  offset;
   GR_RGB_FLOAT[ GR_MAX_GAMMA_RAMP_CONTROL_POINTS ] gammaCurve;
}

struct GR_WSI_WIN_GAMMA_RAMP_CAPABILITIES  {
   GR_BOOL   supportsScaleAndOffset;
   GR_FLOAT  minConvertedValue;
   GR_FLOAT  maxConvertedValue;
   GR_UINT   controlPointCount;
   GR_FLOAT[ GR_MAX_GAMMA_RAMP_CONTROL_POINTS ] controlPointPositions;
}

alias void * HWND;
struct GR_WSI_WIN_PRESENT_INFO  {
   HWND     hWndDest;
   GR_IMAGE srcImage;
   GR_ENUM  presentMode;
   GR_UINT  presentInterval;
   GR_FLAGS flags;
}

struct GR_WSI_WIN_PRESENTABLE_IMAGE_CREATE_INFO  {
   GR_FORMAT          format;
   GR_FLAGS           usage;
   GR_EXTENT2D        extent;
   GR_WSI_WIN_DISPLAY display;
   GR_FLAGS           flags;
}

struct _GR_WSI_WIN_PRESENTABLE_IMAGE_PROPERTIES  {
   GR_WSI_WIN_PRESENTABLE_IMAGE_CREATE_INFO createInfo;
   GR_GPU_MEMORY                            mem;
}

struct GR_WSI_WIN_QUEUE_PROPERTIES  {
   GR_FLAGS presentSupport;
}


/* WSI Extension Errors and Return Codes */
// GR_WSI_WIN_PRESENT_OCCLUDED
// GR_WSI_WIN_ERROR_FULLSCREEN_UNAVAILABLE
// GR_WSI_WIN_ERROR_DISPLAY_REMOVED
// GR_WSI_WIN_ERROR_INCOMPATIBLE_DISPLAY_MODE
// GR_WSI_WIN_ERROR_MULTI_DEVICE_PRESENT_FAILED
// GR_WSI_WIN_ERROR_WINDOWED_PRESENT_UNAVAILABLE
// GR_WSI_WIN_ERROR_INVALID_RESOLUTION

/* --------- */
/* Functions */
/* --------- */

extern( Windows ) @nogc nothrow  {

   /* WSI Extension Functions */
   alias da_grWsiWinGetDisplays = GR_RESULT function(
      GR_DEVICE device,
      GR_UINT * pDisplayCount,
      GR_WSI_WIN_DISPLAY * pDisplayList );

   alias da_grWsiWinGetDisplayModeList = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display,
      GR_UINT * pDisplayModeCount,
      GR_WSI_WIN_DISPLAY_MODE * pDisplayModeList );

   alias da_grWsiWinTakeFullscreenOwnership = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display,
      GR_IMAGE image );

   alias da_grWsiWinReleaseFullscreenOwnership = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display );

   alias da_grWsiWinSetGammaRamp = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display,
      const( GR_WSI_WIN_GAMMA_RAMP ) * pGammaRamp );

   alias da_grWsiWinWaitForVerticalBlank = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display );

   alias da_grWsiWinGetScanLine = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display,
      GR_INT * pScanLine );

   alias da_grWsiWinCreatePresentableImage = GR_RESULT function(
      GR_DEVICE device,
      const( GR_WSI_WIN_PRESENTABLE_IMAGE_CREATE_INFO ) * pCreateInfo,
      GR_IMAGE * pImage,
      GR_GPU_MEMORY * pMem );

   alias da_grWsiWinQueuePresent = GR_RESULT function(
      GR_QUEUE queue,
      const( GR_WSI_WIN_PRESENT_INFO ) * pPresentInfo );

   alias da_grWsiWinSetMaxQueuedFrames = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display,
      GR_UINT maxFrames );
}


__gshared  {
   da_grWsiWinGetDisplays                 grWsiWinGetDisplays;
   da_grWsiWinGetDisplayModeList          grWsiWinGetDisplayModeList;
   da_grWsiWinTakeFullscreenOwnership     grWsiWinTakeFullscreenOwnership;
   da_grWsiWinReleaseFullscreenOwnership  grWsiWinReleaseFullscreenOwnership;
   da_grWsiWinSetGammaRamp                grWsiWinSetGammaRamp;
   da_grWsiWinWaitForVerticalBlank        grWsiWinWaitForVerticalBlank;
   da_grWsiWinGetScanLine                 grWsiWinGetScanLine;
   da_grWsiWinCreatePresentableImage      grWsiWinCreatePresentableImage;
   da_grWsiWinQueuePresent                grWsiWinQueuePresent;
   da_grWsiWinSetMaxQueuedFrames          grWsiWinSetMaxQueuedFrames;
}
