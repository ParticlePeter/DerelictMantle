/*

Boost Software License - Version 1.0 - August 17th,2003

Permission is hereby granted,free of charge,to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use,reproduce,display,distribute,
execute,and transmit the Software,and to prepare derivative works of the
Software,and to permit third-parties to whom the Software is furnished to
do so,all subject to the following:

The copyright notices in the Software and this entire statement,including
the above license grant,this restriction and the following disclaimer,
must be included in all copies of the Software,in whole or in part,and
all derivative works of the Software,unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR
IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE,TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY,WHETHER IN CONTRACT,TORT OR OTHERWISE,
ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

module derelict.mantle.mantle;


private {
   import derelict.util.loader;
   import derelict.util.system;
   import derelict.util.exception;
   
   static if( Derelict_OS_Windows )
      enum libNames = "mantle32.dll";
   else
      static assert( 0,"Need to implement GLFW libNames for this operating system." );
}


/* ------------------- */
/* types and constants */
/* ------------------- */

alias GR_CHAR                       = char;
alias GR_INT                        = int;
alias GR_UINT                       = uint;
alias GR_UINT8                      = ubyte;
alias GR_UINT32                     = uint;
alias GR_UINT64                     = ulong;
alias GR_FLOAT                      = float;
alias GR_BOOL                       = uint;
alias GR_VOID                       = void;
  
alias GR_SIZE                       = size_t;
alias GR_GPU_SIZE                   = ulong;

alias GR_ENUM                       = int;
alias GR_FLAGS                      = int;
alias GR_SAMPLE_MASK                = uint;  // Guess

alias GR_PHYSICAL_GPU               = uint;
alias GR_DEVICE                     = uint;
alias GR_WSI_WIN_DISPLAY            = uint;
alias GR_QUEUE                      = uint;
alias GR_IMAGE                      = uint;
alias GR_GPU_MEMORY                 = uint;
alias GR_CMD_BUFFER                 = uint;
alias GR_FENCE                      = uint;
alias GR_BASE_OBJECT                = uint;
alias GR_VIEWPORT_STATE_OBJECT      = uint;
alias GR_COLOR_TARGET_VIEW          = uint;
alias GR_DESCRIPTOR_SET             = uint;
alias GR_OBJECT                     = uint;
alias GR_MSAA_STATE_OBJECT          = uint;
alias GR_SAMPLER                    = uint;
alias GR_COLOR_BLEND_STATE_OBJECT   = uint;
alias GR_DEPTH_STENCIL_STATE_OBJECT = uint;
alias GR_RASTER_STATE_OBJECT        = uint;
alias GR_SHADER                     = uint;
alias GR_PIPELINE                   = uint;
alias GR_IMAGE_VIEW                 = uint;
alias GR_DEPTH_STENCIL_VIEW         = uint;
alias GR_STATE_OBJECT               = uint;

const ulong GR_NULL_HANDLE          = 0;

const int GR_MAX_PHYSICAL_GPUS      = 4;
const int GR_API_VERSION            = 1;
const int GR_MAX_PHYSICAL_GPU_NAME  = 255;   // Guess
const int GR_MAX_VIEWPORTS          = 16;    // Guess
const int GR_MAX_MEMORY_HEAPS       = 8;
const int GR_MAX_COLOR_TARGETS      = 16;    // Guess
const int GR_MAX_DESCRIPTOR_SETS    = 2;

const GR_BOOL GR_TRUE  = 1;
const GR_BOOL GR_FALSE = 0;

alias GR_RESULT                     = uint;
alias GR_INFO_TYPE                  = uint;
alias GR_PHYSICAL_GPU_TYPE          = uint;
alias GR_QUEUE_TYPE                 = uint;
alias GR_VALIDATION_LEVEL           = uint;
alias GR_DEVICE_CREATE_FLAGS        = uint;
alias GR_CHANNEL_FORMAT             = uint;
alias GR_NUM_FORMAT                 = uint;
alias GR_IMAGE_USAGE_FLAGS          = uint;
alias GR_WSI_WIN_IMAGE_CREATE_FLAGS = uint;
alias GR_CMD_BUFFER_BUILD_FLAGS     = uint;
alias GR_IMAGE_STATE                = uint;
alias GR_WSI_WIN_IMAGE_STATE        = uint;
alias GR_IMAGE_ASPECT               = uint;
alias GR_WSI_WIN_PRESENT_MODE       = uint;
alias GR_WSI_WIN_PRESENT_FLAGS      = uint;
alias GR_MEMORY_PRIORITY            = uint;
alias GR_COMPARE_FUNC               = uint;
alias GR_FILL_MODE                  = uint;
alias GR_CULL_MODE                  = uint;
alias GR_FACE_ORIENTATION           = uint;
alias GR_DESCRIPTOR_SET_SLOT_TYPE   = uint;
alias GR_STATE_BIND_POINT           = uint;
alias GR_BLEND                      = uint;
alias GR_BLEND_FUNC                 = uint;
alias GR_STENCIL_OP                 = uint;
alias GR_INDEX_TYPE                 = uint;
alias GR_PIPELINE_BIND_POINT        = uint;
alias GR_PRIMITIVE_TOPOLOGY         = uint;
alias GR_LOGIC_OP                   = uint;
alias GR_SHADER_CREATE_FLAGS        = uint;
alias GR_MEMORY_HEAP_FLAGS          = uint;
alias GR_MEMORY_STATE               = uint;

enum /*GR_RESULT*/  {
   GR_SUCCESS = 0x10000,
   GR_UNSUPPORTED,
   GR_NOT_READY,
   GR_TIMEOUT,
   GR_EVENT_SET,
   GR_EVENT_RESET,

   GR_ERROR_UNKNOW = 0x11000,
   GR_ERROR_UNAVAILABLE,
   GR_ERROR_INITIALIZATION_FAILED,
   GR_ERROR_OUT_OF_MEMORY,
   GR_ERROR_OUT_OF_GPU_MEMORY,
   GR_ERROR_DEVICE_ALREADY_CREATED,
   GR_ERROR_DEVICE_LOST,
   GR_ERROR_INVALID_POINTER,
   GR_ERROR_INVALID_VALUE,
   GR_ERROR_INVALID_HANDLE,
   GR_ERROR_INVALID_ORDINAL,
   GR_ERROR_INVALID_MEMORY_SIZE,
   GR_ERROR_INVALID_EXTENSION,
   GR_ERROR_INVALID_FLAGS,
   GR_ERROR_INVALID_ALIGNMENT,
   GR_ERROR_INVALID_FORMAT,
   GR_ERROR_INVALID_IMAGE,
   GR_ERROR_INVALID_DESCRIPTOR_SET_DATA,
   GR_ERROR_INVALID_QUEUE_TYPE,
   GR_ERROR_INVALID_OBJECT_TYPE,
   GR_ERROR_UNSUPPORTED_SHADER_IL_VERSION,
   GR_ERROR_BAD_SHADER_CODE,
   GR_ERROR_BAD_PIPELINE_DATA,
   GR_ERROR_TOO_MANY_MEMORY_REFERENCES,
   GR_ERROR_NOT_MAPPABLE,
   GR_ERROR_MEMORY_MAP_FAILED,
   GR_ERROR_MEMORY_UNMAP_FAILED,
   GR_ERROR_INCOMPATIBLE_DEVICE,
   GR_ERROR_INCOMPATIBLE_DRIVER,
   GR_ERROR_INCOMPLETE_COMMAND_BUFFER,
   GR_ERROR_BUILDING_COMMAND_BUFFER,
   GR_ERROR_MEMORY_NOT_BOUND,
   GR_ERROR_INCOMPATIBLE_QUEUE,
   GR_ERROR_NOT_SHAREABLE
}

enum /*GR_INFO_TYPE*/  {
   GR_INFO_TYPE_PHYSICAL_GPU_PROPERTIES = 0x6100,
   GR_INFO_TYPE_PHYSICAL_GPU_PERFORMANCE,
   GR_INFO_TYPE_PHYSICAL_GPU_QUEUE_PROPERTIES,
   GR_INFO_TYPE_PHYSICAL_GPU_MEMORY_PROPERTIES,
   GR_INFO_TYPE_PHYSICAL_GPU_IMAGE_PROPERTIES,
   GR_INFO_TYPE_MEMORY_HEAP_PROPERTIES = 0x6200,
   GR_INFO_TYPE_FORMAT_PROPERTIES = 0x6300,
   GR_INFO_TYPE_SUBRESOURCE_LAYOUT = 0x6400,
   GR_INFO_TYPE_MEMORY_REQUIREMENTS = 0x6800,
   GR_INFO_TYPE_PARENT_DEVICE,
   GR_INFO_TYPE_PARENT_PHYSICAL_GPU,
}

enum /*GR_PHYSICAL_GPU_TYPE*/  {
   GR_GPU_TYPE_OTHER = 0x3000,
   GR_GPU_TYPE_INTEGRATED,
   GR_GPU_TYPE_DISCRETE,
   GR_GPU_TYPE_VIRTUAL,
}

enum /*GR_QUEUE_TYPE*/  {
   GR_QUEUE_UNIVERSAL = 0x1000,
   GR_QUEUE_COMPUTE,
   GR_EXT_QUEUE_DMA = 0x00300200,
   GR_EXT_QUEUE_TIMER
}

enum /*GR_VALIDATION_LEVEL*/  {
   GR_VALIDATION_LEVEL_0 = 0x8000,
   GR_VALIDATION_LEVEL_1,
   GR_VALIDATION_LEVEL_2,
   GR_VALIDATION_LEVEL_3,
   GR_VALIDATION_LEVEL_4,
}

enum /*GR_DEVICE_CREATE_FLAGS*/  {
   GR_DEVICE_CREATE_VALIDATION = 0x00000001,
}

enum /*GR_CHANNEL_FORMAT*/  {
   GR_CH_FMT_UNDEFINED,
   GR_CH_FMT_R4G4,
   GR_CH_FMT_R4G4B4A4,
   GR_CH_FMT_R5G6B5,
   GR_CH_FMT_B5G6R5,
   GR_CH_FMT_R5G5B5A1,
   GR_CH_FMT_R8,
   GR_CH_FMT_R8G8,
   GR_CH_FMT_R8G8B8A8,
   GR_CH_FMT_B8G8R8A8,
   GR_CH_FMT_R10G11B11,
   GR_CH_FMT_R11G11B10,
   GR_CH_FMT_R10G10B10A2,
   GR_CH_FMT_R16,
   GR_CH_FMT_R16G16,
   GR_CH_FMT_R16G16B16A16,
   GR_CH_FMT_R32,
   GR_CH_FMT_R32G32,
   GR_CH_FMT_R32G32B32,
   GR_CH_FMT_R32G32B32A32,
   GR_CH_FMT_R16G8,
   GR_CH_FMT_R32G8,
   GR_CH_FMT_R9G9B9E5,
   GR_CH_FMT_BC1,
   GR_CH_FMT_BC2,
   GR_CH_FMT_BC3,
   GR_CH_FMT_BC4,
   GR_CH_FMT_BC5,
   GR_CH_FMT_BC6U,
   GR_CH_FMT_BC6S,
   GR_CH_FMT_BC7
}

enum /*GR_NUM_FORMAT*/  {
   GR_NUM_FMT_UNDEFINED,
   GR_NUM_FMT_UNORM,
   GR_NUM_FMT_SNORM,
   GR_NUM_FMT_UINT,
   GR_NUM_FMT_SINT,
   GR_NUM_FMT_FLOAT,
   GR_NUM_FMT_SRGB,
   GR_NUM_FMT_DS
}

enum /*GR_IMAGE_USAGE_FLAGS*/  {
   GR_IMAGE_USAGE_SHADER_ACCESS_READ = 0x00000001,
   GR_IMAGE_USAGE_SHADER_ACCESS_WRITE = 0x00000002,
   GR_IMAGE_USAGE_COLOR_TARGET = 0x00000004,
   GR_IMAGE_USAGE_DEPTH_STENCIL = 0x00000008,
}

enum /*GR_WSI_WIN_IMAGE_CREATE_FLAGS*/  {
   GR_WSI_WIN_IMAGE_CREATE_FULLSCREEN_PRESENT = 0x00000001,
   GR_WSI_WIN_IMAGE_CREATE_STEREO = 0x00000002,
}

enum /*GR_CMD_BUFFER_BUILD_FLAGS*/  {
   GR_CMD_BUFFER_OPTIMIZE_GPU_SMALL_BATCH = 0x00000001,
   GR_CMD_BUFFER_OPTIMIZE_PIPELINE_SWITCH = 0x00000002,
   GR_CMD_BUFFER_OPTIMIZE_ONE_TIME_SUBMIT = 0x00000004,
   GR_CMD_BUFFER_OPTIMIZE_DESCRIPTOR_SET_SWITCH = 0x00000008,
}

enum /*GR_IMAGE_STATE*/  {
   GR_IMAGE_STATE_DATA_TRANSFER = 0x1300,
   GR_IMAGE_STATE_GRAPHICS_SHADER_READ_ONLY = 0x1301,
   GR_IMAGE_STATE_GRAPHICS_SHADER_WRITE_ONLY = 0x1302,
   GR_IMAGE_STATE_GRAPHICS_SHADER_READ_WRITE = 0x1303,
   GR_IMAGE_STATE_COMPUTE_SHADER_READ_ONLY = 0x1304,
   GR_IMAGE_STATE_COMPUTE_SHADER_WRITE_ONLY = 0x1305,
   GR_IMAGE_STATE_COMPUTE_SHADER_READ_WRITE = 0x1306,
   GR_IMAGE_STATE_MULTI_SHADER_READ_ONLY = 0x1307,
   GR_IMAGE_STATE_TARGET_AND_SHADER_READ_ONLY = 0x1308,
   GR_IMAGE_STATE_UNINITIALIZED = 0x1309,
   GR_IMAGE_STATE_TARGET_RENDER_ACCESS_OPTIMAL = 0x130a,
   GR_IMAGE_STATE_TARGET_SHADER_ACCESS_OPTIMAL = 0x130b,
   GR_IMAGE_STATE_CLEAR = 0x130c,
   GR_IMAGE_STATE_RESOLVE_SOURCE = 0x130d,
   GR_IMAGE_STATE_RESOLVE_DESTINATION = 0x130e,
   GR_IMAGE_STATE_DISCARD = 0x131f,
   GR_IMAGE_STATE_DATA_TRANSFER_SOURCE = 0x1310,
   GR_IMAGE_STATE_DATA_TRANSFER_DESTINATION = 0x1311,
}

enum /*GR_WSI_WIN_IMAGE_STATE*/  {
   GR_WSI_WIN_IMAGE_STATE_PRESENT_WINDOWED = 0x00200000,
   GR_WSI_WIN_IMAGE_STATE_PRESENT_FULLSCREEN = 0x00200001,
}

enum /*GR_IMAGE_ASPECT*/  {
   GR_IMAGE_ASPECT_COLOR = 0x1700,
   GR_IMAGE_ASPECT_DEPTH = 0x1701,
   GR_IMAGE_ASPECT_STENCIL = 0x1702,
}

enum /*GR_WSI_WIN_PRESENT_MODE*/  {
   GR_WSI_WIN_PRESENT_MODE_WINDOWED = 0x00200200,
   GR_WSI_WIN_PRESENT_MODE_FULLSCREEN = 0x00200201,
}

enum /*GR_WSI_WIN_PRESENT_FLAGS*/  {
   GR_WSI_WIN_PRESENT_FULLSCREEN_DONOTWAIT = 0x00000001,
   GR_WSI_WIN_PRESENT_FULLSCREEN_STEREO = 0x00000002,
}

enum /*GR_MEMORY_PRIORITY*/  {
   GR_MEMORY_PRIORITY_NORMAL = 0x1100,
   GR_MEMORY_PRIORITY_HIGH = 0x1101,
   GR_MEMORY_PRIORITY_LOW = 0x1102,
   GR_MEMORY_PRIORITY_UNUSED = 0x1103,
   GR_MEMORY_PRIORITY_VERY_HIGH = 0x1104,
   GR_MEMORY_PRIORITY_VERY_LOW = 0x1105,
}

enum /*GR_COMPARE_FUNC*/  {
   GR_COMPARE_NEVER = 0x2500,
   GR_COMPARE_LESS = 0x2501,
   GR_COMPARE_EQUAL = 0x2502,
   GR_COMPARE_LESS_EQUAL = 0x2503,
   GR_COMPARE_GREATER = 0x2504,
   GR_COMPARE_NOT_EQUAL = 0x2505,
   GR_COMPARE_GREATER_EQUAL = 0x2506,
   GR_COMPARE_ALWAYS = 0x2507,
}

struct GR_DEPTH_STENCIL_OP  {
   GR_ENUM stencilFailOp;
   GR_ENUM stencilPassOp;
   GR_ENUM stencilDepthFailOp;
   GR_ENUM stencilFunc;
   GR_UINT8 stencilRef;
}

enum /*GR_FILL_MODE*/  {
   GR_FILL_SOLID = 0x2600,
   GR_FILL_WIREFRAME = 0x2601,
}

enum /*GR_CULL_MODE*/  {
   GR_CULL_NONE = 0x2700,
   GR_CULL_FRONT = 0x2701,
   GR_CULL_BACK = 0x2702,
}

enum /*GR_FACE_ORIENTATION*/  {
   GR_FRONT_FACE_CCW = 0x2800,
   GR_FRONT_FACE_CW = 0x2801,
}

enum /*GR_DESCRIPTOR_SET_SLOT_TYPE*/  {
   GR_SLOT_UNUSED = 0x1900,
   GR_SLOT_SHADER_RESOURCE,
   GR_SLOT_SHADER_UAV,
   GR_SLOT_SHADER_SAMPLER,
   GR_SLOT_NEXT_DESCRIPTOR_SET,
}

enum /*GR_STATE_BIND_POINT*/  {
   GR_STATE_BIND_VIEWPORT = 0x1f00,
   GR_STATE_BIND_RASTER = 0x1f01,
   GR_STATE_BIND_DEPTH_STENCIL = 0x1f02,
   GR_STATE_BIND_COLOR_BLEND = 0x1f03,
   GR_STATE_BIND_MSAA = 0x1f04,
}

enum /*GR_BLEND*/  {
   GR_BLEND_ZERO = 0x2900,
   GR_BLEND_ONE = 0x2901,
   GR_BLEND_SRC_COLOR = 0x2902,
   GR_BLEND_ONE_MINUS_SRC_COLOR = 0x2903,
   GR_BLEND_DEST_COLOR = 0x2904,
   GR_BLEND_ONE_MINUS_DEST_COLOR = 0x2905,
   GR_BLEND_SRC_ALPHA = 0x2906,
   GR_BLEND_ONE_MINUS_SRC_ALPHA = 0x2907,
   GR_BLEND_DEST_ALPHA = 0x2908,
   GR_BLEND_ONE_MINUS_DEST_ALPHA = 0x2909,
   GR_BLEND_CONSTANT_COLOR = 0x290a,
   GR_BLEND_ONE_MINUS_CONSTANT_COLOR = 0x290b,
   GR_BLEND_CONSTANT_ALPHA = 0x290c,
   GR_BLEND_ONE_MINUS_CONSTANT_ALPHA = 0x290d,
   GR_BLEND_SRC_ALPHA_SATURATE = 0x290e,
   GR_BLEND_SRC1_COLOR = 0x290f,
   GR_BLEND_ONE_MINUS_SRC1_COLOR = 0x2910,
   GR_BLEND_SRC1_ALPHA = 0x2911,
   GR_BLEND_ONE_MINUS_SRC1_ALPHA = 0x2912,
}

enum /*GR_BLEND_FUNC*/  {
   GR_BLEND_FUNC_ADD = 0x2a00,
   GR_BLEND_FUNC_SUBTRACT = 0x2a01,
   GR_BLEND_FUNC_REVERSE_SUBTRACT = 0x2a02,
   GR_BLEND_FUNC_MIN = 0x2a03,
   GR_BLEND_FUNC_MAX = 0x2a04,
}

enum /*GR_STENCIL_OP*/  {
   GR_STENCIL_OP_KEEP = 0x2b00,
   GR_STENCIL_OP_ZERO = 0x2b01,
   GR_STENCIL_OP_REPLACE = 0x2b02,
   GR_STENCIL_OP_INC_CLAMP = 0x2b03,
   GR_STENCIL_OP_DEC_CLAMP = 0x2b04,
   GR_STENCIL_OP_INVERT = 0x2b05,
   GR_STENCIL_OP_INC_WRAP = 0x2b06,
   GR_STENCIL_OP_DEC_WRAP = 0x2b07,
}

enum /*GR_INDEX_TYPE*/  {
   GR_INDEX_16 = 0x2100,
   GR_INDEX_32 = 0x2101,
}

enum /*GR_PIPELINE_BIND_POINT*/  {
   GR_PIPELINE_BIND_POINT_COMPUTE = 0x1e00,
   GR_PIPELINE_BIND_POINT_GRAPHICS = 0x1e01,
}

enum /*GR_PRIMITIVE_TOPOLOGY*/  {
   GR_TOPOLOGY_POINT_LIST = 0x2000,
   GR_TOPOLOGY_LINE_LIST = 0x2001,
   GR_TOPOLOGY_LINE_STRIP = 0x2002,
   GR_TOPOLOGY_TRIANGLE_LIST = 0x2003,
   GR_TOPOLOGY_TRIANGLE_STRIP = 0x2004,
   GR_TOPOLOGY_RECT_LIST = 0x2005,
   GR_TOPOLOGY_QUAD_LIST = 0x2006,
   GR_TOPOLOGY_QUAD_STRIP = 0x2007,
   GR_TOPOLOGY_LINE_LIST_ADJ = 0x2008,
   GR_TOPOLOGY_LINE_STRIP_ADJ = 0x2009,
   GR_TOPOLOGY_TRIANGLE_LIST_ADJ = 0x200a,
   GR_TOPOLOGY_TRIANGLE_STRIP_ADJ = 0x200b,
   GR_TOPOLOGY_PATCH = 0x200c,
}

enum /*GR_LOGIC_OP*/  {
   GR_LOGIC_OP_COPY = 0x2c00,
   GR_LOGIC_OP_CLEAR = 0x2c01,
   GR_LOGIC_OP_AND = 0x2c02,
   GR_LOGIC_OP_AND_REVERSE = 0x2c03,
   GR_LOGIC_OP_AND_INVERTED = 0x2c04,
   GR_LOGIC_OP_NOOP = 0x2c05,
   GR_LOGIC_OP_XOR = 0x2c06,
   GR_LOGIC_OP_OR = 0x2c07,
   GR_LOGIC_OP_NOR = 0x2c08,
   GR_LOGIC_OP_EQUIV = 0x2c09,
   GR_LOGIC_OP_INVERT = 0x2c0a,
   GR_LOGIC_OP_OR_REVERSE = 0x2c0b,
   GR_LOGIC_OP_COPY_INVERTED = 0x2c0c,
   GR_LOGIC_OP_OR_INVERTED = 0x2c0d,
   GR_LOGIC_OP_NAND = 0x2c0e,
   GR_LOGIC_OP_SET = 0x2c0f,
}

enum /*GR_SHADER_CREATE_FLAGS*/  {
   GR_SHADER_CREATE_ALLOW_RE_Z = 0x00000001,
}

enum /*GR_MEMORY_HEAP_FLAGS*/ {
   GR_MEMORY_HEAP_CPU_VISIBLE = 0x00000001,
   GR_MEMORY_HEAP_CPU_GPU_COHERENT = 0x00000002,
   GR_MEMORY_HEAP_CPU_UNCACHED = 0x00000004,
   GR_MEMORY_HEAP_CPU_WRITE_COMBINED = 0x00000008,
   GR_MEMORY_HEAP_HOLDS_PINNED = 0x00000010,
   GR_MEMORY_HEAP_SHAREABLE = 0x00000020,
}

enum /*GR_MEMORY_STATE*/ {
   GR_MEMORY_STATE_DATA_TRANSFER = 0x1200,
   GR_MEMORY_STATE_GRAPHICS_SHADER_READ_ONLY = 0x1201,
   GR_MEMORY_STATE_GRAPHICS_SHADER_WRITE_ONLY = 0x1202,
   GR_MEMORY_STATE_GRAPHICS_SHADER_READ_WRITE = 0x1203,
   GR_MEMORY_STATE_COMPUTE_SHADER_READ_ONLY = 0x1204,
   GR_MEMORY_STATE_COMPUTE_SHADER_WRITE_ONLY = 0x1205,
   GR_MEMORY_STATE_COMPUTE_SHADER_READ_WRITE = 0x1206,
   GR_MEMORY_STATE_MULTI_USE_READ_ONLY = 0x1207,
   GR_MEMORY_STATE_INDEX_DATA = 0x1208,
   GR_MEMORY_STATE_INDIRECT_ARG = 0x1209,
   GR_MEMORY_STATE_WRITE_TIMESTAMP = 0x120a,
   GR_MEMORY_STATE_QUEUE_ATOMIC = 0x120b,
   GR_MEMORY_STATE_DISCARD = 0x120c,
   GR_MEMORY_STATE_DATA_TRANSFER_SOURCE = 0x120d,
   GR_MEMORY_STATE_DATA_TRANSFER_DESTINATION = 0x120e,
}

/* ---------- */
/* structures */
/* ---------- */

struct GR_APPLICATION_INFO  {
   const GR_CHAR * pAppName;
   GR_UINT32 appVersion;
   const GR_CHAR * pEngineName;
   GR_UINT32 engineVersion;
   GR_UINT32 apiVersion;
}

struct GR_ALLOC_CALLBACKS  {
   GR_ALLOC_FUNCTION pfnAlloc;
   GR_FREE_FUNCTION pfnFree;
}

struct GR_PHYSICAL_GPU_PROPERTIES  {
   GR_UINT32   apiVersion;
   GR_UINT32   driverVersion;
   GR_UINT32   vendorId;
   GR_UINT32   deviceId;
   GR_ENUM     gpuType;
   GR_CHAR[ GR_MAX_PHYSICAL_GPU_NAME ] gpuName;
   GR_UINT     maxMemRefsPerSubmission;
   GR_GPU_SIZE reserved;
   GR_GPU_SIZE maxInlineMemoryUpdateSize;
   GR_UINT     maxBoundDescriptorSets;
   GR_UINT     maxThreadGroupSize;
   GR_UINT64   timestampFrequency;
   GR_BOOL     multiColorTargetClears;
}

struct GR_PHYSICAL_GPU_PERFORMANCE  {
   GR_FLOAT maxGpuClock;
   GR_FLOAT aluPerClock;
   GR_FLOAT texPerClock;
   GR_FLOAT primsPerClock;
   GR_FLOAT pixelsPerClock;
}

struct GR_PHYSICAL_GPU_QUEUE_PROPERTIES  {
   GR_ENUM queueType;
   GR_UINT queueCount;
   GR_UINT maxAtomicCounters;
   GR_BOOL supportsTimestamps;
}

struct GR_DEVICE_QUEUE_CREATE_INFO  {
   GR_ENUM queueType;
   GR_UINT queueCount;
}

struct GR_DEVICE_CREATE_INFO  {
   GR_UINT queueRecordCount;
   const( GR_DEVICE_QUEUE_CREATE_INFO ) * pRequestedQueues;
   GR_UINT extensionCount;
   const( GR_CHAR * ) * ppEnabledExtensionNames;
   GR_ENUM maxValidationLevel;
   GR_FLAGS flags;
}

struct GR_EXTENT2D  {
   GR_INT width;
   GR_INT height;
}

struct GR_EXTENT3D  {
   GR_INT width;
   GR_INT height;
   GR_INT depth;
}

struct GR_FORMAT  {
   //GR_UINT32 channelFormat : 16;
   //GR_UINT32 numericFormat : 16;
   ushort channelFormat;
   ushort numericFormat;
}

struct GR_WSI_WIN_DISPLAY_MODE  {
   GR_EXTENT2D extent;
   GR_FORMAT format;
   GR_UINT refreshRate;
   GR_BOOL stereo;
   GR_BOOL crossDisplayPresent;
}

struct GR_WSI_WIN_PRESENTABLE_IMAGE_CREATE_INFO  {
   GR_FORMAT format;
   GR_FLAGS usage;
   GR_EXTENT2D extent;
   GR_WSI_WIN_DISPLAY display;
   GR_FLAGS flags;
}

struct GR_CMD_BUFFER_CREATE_INFO  {
   GR_ENUM queueType;
   GR_FLAGS flags;
}

struct GR_MEMORY_REF  {
   GR_GPU_MEMORY mem;
   GR_FLAGS flags;
}

struct GR_IMAGE_SUBRESOURCE_RANGE  {
   GR_ENUM aspect;
   GR_UINT baseMipLevel;
   GR_UINT mipLevels;
   GR_UINT baseArraySlice;
   GR_UINT arraySize;
}

struct GR_IMAGE_STATE_TRANSITION  {
   GR_IMAGE image;
   GR_ENUM oldState;
   GR_ENUM newState;
   GR_IMAGE_SUBRESOURCE_RANGE subresourceRange;
}

alias void * HWND;
struct GR_WSI_WIN_PRESENT_INFO  {
   HWND hWndDest;
   GR_IMAGE srcImage;
   GR_ENUM presentMode;
   GR_UINT presentInterval;
   GR_FLAGS flags;
}

struct GR_VIEWPORT  {
   GR_FLOAT originX;
   GR_FLOAT originY;
   GR_FLOAT width;
   GR_FLOAT height;
   GR_FLOAT minDepth;
   GR_FLOAT maxDepth;
}

struct GR_OFFSET2D  {
   GR_INT x;
   GR_INT y;
}

struct GR_OFFSET3D  {
   GR_INT x;
   GR_INT y;
   GR_INT z;
}

struct GR_RECT  {
   GR_OFFSET2D offset;
   GR_EXTENT2D extent;
}

struct GR_VIEWPORT_STATE_CREATE_INFO  {
   GR_UINT viewportCount;
   GR_BOOL scissorEnable;
   GR_VIEWPORT[GR_MAX_VIEWPORTS] viewports;
   GR_RECT[GR_MAX_VIEWPORTS] scissors;
}

struct GR_COLOR_TARGET_VIEW_CREATE_INFO  {
   GR_IMAGE image;
   GR_FORMAT format;
   GR_UINT mipLevel;
   GR_UINT baseArraySlice;
   GR_UINT arraySize;
}

struct GR_MEMORY_ALLOC_INFO  {
   GR_GPU_SIZE size;
   GR_GPU_SIZE alignment;
   GR_FLAGS flags;
   GR_UINT heapCount;
   GR_UINT[GR_MAX_MEMORY_HEAPS] heaps;
   GR_ENUM memPriority;
}

struct GR_DESCRIPTOR_SET_CREATE_INFO  {
   GR_UINT slots;
}

struct GR_FENCE_CREATE_INFO  {
   GR_FLAGS flags;
}

struct GR_MSAA_STATE_CREATE_INFO  {
   GR_UINT samples;
   GR_SAMPLE_MASK sampleMask;
}

struct GR_SAMPLER_CREATE_INFO  {
   GR_ENUM filter;
   GR_ENUM addressU;
   GR_ENUM addressV;
   GR_ENUM addressW;
   GR_FLOAT mipLodBias;
   GR_UINT maxAnisotropy;
   GR_ENUM compareFunc;
   GR_FLOAT minLod;
   GR_FLOAT maxLod;
   GR_ENUM borderColor;
}

struct GR_COLOR_TARGET_BLEND_STATE  {
   GR_BOOL blendEnable;
   GR_ENUM srcBlendColor;
   GR_ENUM destBlendColor;
   GR_ENUM blendFuncColor;
   GR_ENUM srcBlendAlpha;
   GR_ENUM destBlendAlpha;
   GR_ENUM blendFuncAlpha;
}

struct GR_COLOR_BLEND_STATE_CREATE_INFO  {
   GR_COLOR_TARGET_BLEND_STATE[GR_MAX_COLOR_TARGETS] target;
   GR_FLOAT[4] blendConst;
}

struct GR_DEPTH_STENCIL_STATE_CREATE_INFO  {
   GR_BOOL depthEnable;
   GR_BOOL depthWriteEnable;
   GR_ENUM depthFunc;
   GR_BOOL depthBoundsEnable;
   GR_FLOAT minDepth;
   GR_FLOAT maxDepth;
   GR_BOOL stencilEnable;
   GR_UINT8 stencilReadMask;
   GR_UINT8 stencilWriteMask;
   GR_DEPTH_STENCIL_OP front;
   GR_DEPTH_STENCIL_OP back;
}

struct GR_RASTER_STATE_CREATE_INFO  {
   GR_ENUM fillMode;
   GR_ENUM cullMode;
   GR_ENUM frontFace;
   GR_INT depthBias;
   GR_FLOAT depthBiasClamp;
   GR_FLOAT slopeScaledDepthBias;
}

struct GR_SHADER_CREATE_INFO  {
   GR_SIZE codeSize;
   const( GR_VOID ) * pCode;
   GR_FLAGS flags;
}

struct GR_DESCRIPTOR_SLOT_INFO  {
   GR_ENUM slotObjectType;
   union  {
      GR_UINT shaderEntityIndex;
      const( GR_DESCRIPTOR_SET_MAPPING ) * pNextLevelSet;
   }
}

struct GR_DESCRIPTOR_SET_MAPPING  {
   GR_UINT descriptorCount;
   const( GR_DESCRIPTOR_SLOT_INFO ) * pDescriptorInfo;
}

struct GR_LINK_CONST_BUFFER  {
   GR_UINT bufferId;
   GR_SIZE bufferSize;
   const( GR_VOID ) * pBufferData;
}

struct GR_DYNAMIC_MEMORY_VIEW_SLOT_INFO  {
   GR_ENUM slotObjectType;
   GR_UINT shaderEntityIndex;
}

struct GR_PIPELINE_SHADER  {
   GR_SHADER shader;
   GR_DESCRIPTOR_SET_MAPPING[GR_MAX_DESCRIPTOR_SETS] descriptorSetMapping;
   GR_UINT linkConstBufferCount;
   const( GR_LINK_CONST_BUFFER ) * pLinkConstBufferInfo;
   GR_DYNAMIC_MEMORY_VIEW_SLOT_INFO dynamicMemoryViewMapping;
}

struct GR_PIPELINE_IA_STATE  {
   GR_ENUM topology;
   GR_BOOL disableVertexReuse;
}

struct GR_PIPELINE_TESS_STATE  {
   GR_UINT patchControlPoints;
   GR_FLOAT optimalTessFactor;
}

struct GR_PIPELINE_RS_STATE  {
   GR_BOOL depthClipEnable;
}

struct GR_PIPELINE_CB_TARGET_STATE  {
   GR_BOOL blendEnable;
   GR_FORMAT format;
   GR_UINT8 channelWriteMask;
}

struct GR_PIPELINE_CB_STATE  {
   GR_BOOL alphaToCoverageEnable;
   GR_BOOL dualSourceBlendEnable;
   GR_ENUM logicOp;
   GR_PIPELINE_CB_TARGET_STATE[GR_MAX_COLOR_TARGETS] target;
}

struct GR_PIPELINE_DB_STATE  {
   GR_FORMAT format;
}

struct GR_GRAPHICS_PIPELINE_CREATE_INFO  {
   GR_PIPELINE_SHADER vs;
   GR_PIPELINE_SHADER hs;
   GR_PIPELINE_SHADER ds;
   GR_PIPELINE_SHADER gs;
   GR_PIPELINE_SHADER ps;
   GR_PIPELINE_IA_STATE iaState;
   GR_PIPELINE_TESS_STATE tessState;
   GR_PIPELINE_RS_STATE rsState;
   GR_PIPELINE_CB_STATE cbState;
   GR_PIPELINE_DB_STATE dbState;
   GR_FLAGS flags;
}

struct GR_COMPUTE_PIPELINE_CREATE_INFO  {
   GR_PIPELINE_SHADER cs;
   GR_FLAGS flags;
}

struct GR_MEMORY_VIEW_ATTACH_INFO  {
   GR_GPU_MEMORY mem;
   GR_GPU_SIZE offset;
   GR_GPU_SIZE range;
   GR_GPU_SIZE stride;
   GR_FORMAT format;
   GR_ENUM state;
}

struct GR_IMAGE_CREATE_INFO  {
   GR_ENUM imageType;
   GR_FORMAT format;
   GR_EXTENT3D extent;
   GR_UINT mipLevels;
   GR_UINT arraySize;
   GR_UINT samples;
   GR_ENUM tiling;
   GR_FLAGS usage;
   GR_FLAGS flags;
}

struct GR_CHANNEL_MAPPING  {
   GR_ENUM r;
   GR_ENUM g;
   GR_ENUM b;
   GR_ENUM a;
}

struct GR_IMAGE_VIEW_CREATE_INFO  {
   GR_IMAGE image;
   GR_ENUM viewType;
   GR_FORMAT format;
   GR_CHANNEL_MAPPING channels;
   GR_IMAGE_SUBRESOURCE_RANGE subresourceRange;
   GR_FLOAT minLod;
}

struct GR_IMAGE_VIEW_ATTACH_INFO  {
   GR_IMAGE_VIEW view;
   GR_ENUM state;
}

struct GR_IMAGE_SUBRESOURCE  {
   GR_ENUM aspect;
   GR_UINT mipLevel;
   GR_UINT arraySlice;
}

struct GR_MEMORY_STATE_TRANSITION  {
   GR_GPU_MEMORY mem;
   GR_ENUM oldState;
   GR_ENUM newState;
   GR_GPU_SIZE offset;
   GR_GPU_SIZE regionSize;
}

struct GR_MEMORY_COPY  {
   GR_GPU_SIZE srcOffset;
   GR_GPU_SIZE destOffset;
   GR_GPU_SIZE copySize;
}

struct GR_IMAGE_COPY  {
   GR_IMAGE_SUBRESOURCE srcSubresource;
   GR_OFFSET3D srcOffset;
   GR_IMAGE_SUBRESOURCE destSubresource;
   GR_OFFSET3D destOffset;
   GR_EXTENT3D extent;
}

struct GR_COLOR_TARGET_BIND_INFO  {
   GR_COLOR_TARGET_VIEW view;
   GR_ENUM colorTargetState;
}

struct GR_DEPTH_STENCIL_BIND_INFO  {
   GR_DEPTH_STENCIL_VIEW view;
   GR_ENUM depthState;
   GR_ENUM stencilState;
}

struct GR_MEMORY_IMAGE_COPY  {
   GR_GPU_SIZE memOffset;
   GR_IMAGE_SUBRESOURCE imageSubresource;
   GR_OFFSET3D imageOffset;
   GR_EXTENT3D imageExtent;
}

struct GR_DESCRIPTOR_SET_ATTACH_INFO  {
   GR_DESCRIPTOR_SET descriptorSet;
   GR_UINT slotOffset;
}

struct GR_MEMORY_REQUIREMENTS  {
   GR_GPU_SIZE size;
   GR_GPU_SIZE alignment;
   GR_UINT heapCount;
   GR_UINT[GR_MAX_MEMORY_HEAPS] heaps;
}

struct GR_MEMORY_HEAP_PROPERTIES  {
   GR_ENUM heapMemoryType;
   GR_GPU_SIZE heapSize;
   GR_GPU_SIZE pageSize;
   GR_FLAGS flags;
   GR_FLOAT gpuReadPerfRating;
   GR_FLOAT gpuWritePerfRating;
   GR_FLOAT cpuReadPerfRating;
   GR_FLOAT cpuWritePerfRating;
}

/* ------------------ */
/* callback functions */
/* ------------------ */

extern( Windows ) nothrow  {

   alias GR_VOID * function(
      GR_SIZE size,
      GR_SIZE alignment,
      GR_ENUM allocType
   )   GR_ALLOC_FUNCTION;

   alias GR_VOID function(
      GR_VOID * pMem
   )   GR_FREE_FUNCTION;

   alias GR_VOID function(
      GR_ENUM msgType,
      GR_ENUM validationLevel,
      GR_BASE_OBJECT srcObject,
      GR_SIZE location,
      GR_ENUM msgCode,
      const( GR_CHAR ) * pMsg,
      GR_VOID * pUserData
   )   GR_DBG_MSG_CALLBACK_FUNCTION;
}

/* --------------------- */
/* API function pointers */
/* --------------------- */

extern( Windows ) @nogc nothrow  {

   alias da_grInitAndEnumerateGpus = GR_RESULT function(
      const( GR_APPLICATION_INFO ) * pAppInfo,
      const( GR_ALLOC_CALLBACKS ) * pAllocCb,
      GR_UINT * pGpuCount,
      GR_PHYSICAL_GPU * gpus ); // gpus[GR_MAX_PHYSICAL_GPUS]

   alias da_grGetGpuInfo = GR_RESULT function(
      GR_PHYSICAL_GPU gpu,
      GR_ENUM infoType,
      GR_SIZE * pDataSize,
      GR_VOID * pData );

   alias da_grGetExtensionSupport = GR_RESULT function(
      GR_PHYSICAL_GPU gpu,
      const( GR_CHAR ) * pExtName );

   alias da_grCreateDevice = GR_RESULT function(
      GR_PHYSICAL_GPU gpu,
      const( GR_DEVICE_CREATE_INFO ) * pCreateInfo,
      GR_DEVICE * pDevice );

   alias da_grWsiWinGetDisplays = GR_RESULT function(
      GR_DEVICE device,
      GR_UINT * pDisplayCount,
      GR_WSI_WIN_DISPLAY * pDisplayList );

   alias da_grWsiWinGetDisplayModeList = GR_RESULT function(
      GR_WSI_WIN_DISPLAY display,
      GR_UINT * pDisplayModeCount,
      GR_WSI_WIN_DISPLAY_MODE * pDisplayModeList );

   alias da_grGetDeviceQueue = GR_RESULT function(
      GR_DEVICE device,
      GR_ENUM queueType,
      GR_UINT queueId,
      GR_QUEUE * pQueue );

   alias da_grWsiWinCreatePresentableImage = GR_RESULT function(
      GR_DEVICE device,
      const( GR_WSI_WIN_PRESENTABLE_IMAGE_CREATE_INFO ) * pCreateInfo,
      GR_IMAGE * pImage,
      GR_GPU_MEMORY * pMem );

   alias da_grCreateCommandBuffer = GR_RESULT function(
      GR_DEVICE device,
      const( GR_CMD_BUFFER_CREATE_INFO ) * pCreateInfo,
      GR_CMD_BUFFER * pCmdBuffer );

   alias da_grBeginCommandBuffer = GR_RESULT function(
      GR_CMD_BUFFER cmdBuffer,
      GR_FLAGS flags );

   alias da_grEndCommandBuffer = GR_RESULT function(
      GR_CMD_BUFFER cmdBuffer );

   alias da_grQueueSubmit = GR_RESULT function(
      GR_QUEUE queue,
      GR_UINT cmdBufferCount,
      const( GR_CMD_BUFFER ) * pCmdBuffers,
      GR_UINT memRefCount,
      const( GR_MEMORY_REF ) * pMemRefs,
      GR_FENCE fence );

   alias da_grCmdPrepareImages = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_UINT transitionCount,
      const( GR_IMAGE_STATE_TRANSITION ) * pStateTransitions );

   alias da_grCmdClearColorImage = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_IMAGE image,
      const GR_FLOAT * color, //color[4]
      GR_UINT rangeCount,
      const( GR_IMAGE_SUBRESOURCE_RANGE ) * pRanges );

   alias da_grWsiWinQueuePresent = GR_RESULT function(
      GR_QUEUE queue,
      const( GR_WSI_WIN_PRESENT_INFO ) * pPresentInfo );

   alias da_grDbgRegisterMsgCallback = GR_RESULT function(
      GR_DBG_MSG_CALLBACK_FUNCTION pfnMsgCallback,
      GR_VOID * pUserData );

   alias da_grCreateViewportState = GR_RESULT function(
      GR_DEVICE device,
      const( GR_VIEWPORT_STATE_CREATE_INFO ) * pCreateInfo,
      GR_VIEWPORT_STATE_OBJECT * pState );

   alias da_grGetMemoryHeapCount = GR_RESULT function(
      GR_DEVICE device,
      GR_UINT * pCount );

   alias da_grCreateColorTargetView = GR_RESULT function(
      GR_DEVICE device,
      const( GR_COLOR_TARGET_VIEW_CREATE_INFO ) * pCreateInfo,
      GR_COLOR_TARGET_VIEW * pView );

   alias da_grGetMemoryHeapInfo = GR_RESULT function(
      GR_DEVICE device,
      GR_UINT heapId,
      GR_ENUM infoType,
      GR_SIZE * pDataSize,
      GR_VOID * pData );

   alias da_grAllocMemory = GR_RESULT function(
      GR_DEVICE device,
      const( GR_MEMORY_ALLOC_INFO ) * pAllocInfo,
      GR_GPU_MEMORY * pMem );

   alias da_grCreateDescriptorSet = GR_RESULT function(
      GR_DEVICE device,
      const( GR_DESCRIPTOR_SET_CREATE_INFO ) * pCreateInfo,
      GR_DESCRIPTOR_SET * pDescriptorSet );

   alias da_grGetObjectInfo = GR_RESULT function(
      GR_BASE_OBJECT object,
      GR_ENUM infoType,
      GR_SIZE * pDataSize,
      GR_VOID * pData );

   alias da_grBindObjectMemory = GR_RESULT function(
      GR_OBJECT object,
      GR_GPU_MEMORY mem,
      GR_GPU_SIZE offset );

   alias da_grCreateFence = GR_RESULT function(
      GR_DEVICE device,
      const( GR_FENCE_CREATE_INFO ) * pCreateInfo,
      GR_FENCE * pFence );

   alias da_grCreateMsaaState = GR_RESULT function(
      GR_DEVICE device,
      const( GR_MSAA_STATE_CREATE_INFO ) * pCreateInfo,
      GR_MSAA_STATE_OBJECT * pState );

   alias da_grCreateSampler = GR_RESULT function(
      GR_DEVICE device,
      const( GR_SAMPLER_CREATE_INFO ) * pCreateInfo,
      GR_SAMPLER * pSampler );

   alias da_grBeginDescriptorSetUpdate = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet );

   alias da_grEndDescriptorSetUpdate = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet );

   alias da_grAttachSamplerDescriptors = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet,
      GR_UINT startSlot,
      GR_UINT slotCount,
      const( GR_SAMPLER ) * pSamplers );

   alias da_grCreateColorBlendState = GR_RESULT function(
      GR_DEVICE device,
      const( GR_COLOR_BLEND_STATE_CREATE_INFO ) * pCreateInfo,
      GR_COLOR_BLEND_STATE_OBJECT * pState );

   alias da_grCreateDepthStencilState = GR_RESULT function(
      GR_DEVICE device,
      const( GR_DEPTH_STENCIL_STATE_CREATE_INFO ) * pCreateInfo,
      GR_DEPTH_STENCIL_STATE_OBJECT * pState );

   alias da_grCreateRasterState = GR_RESULT function(
      GR_DEVICE device,
      const( GR_RASTER_STATE_CREATE_INFO ) * pCreateInfo,
      GR_RASTER_STATE_OBJECT * pState );

   alias da_grMapMemory = GR_RESULT function(
      GR_GPU_MEMORY mem,
      GR_FLAGS flags,
      GR_VOID ** ppData );

   alias da_grUnmapMemory = GR_RESULT function(
      GR_GPU_MEMORY mem );

   alias da_grCreateShader = GR_RESULT function(
      GR_DEVICE device,
      const( GR_SHADER_CREATE_INFO ) * pCreateInfo,
      GR_SHADER * pShader );

   alias da_grCreateGraphicsPipeline = GR_RESULT function(
      GR_DEVICE device,
      const( GR_GRAPHICS_PIPELINE_CREATE_INFO ) * pCreateInfo,
      GR_PIPELINE * pPipeline );

   alias da_grCreateComputePipeline = GR_RESULT function(
      GR_DEVICE device,
      const( GR_COMPUTE_PIPELINE_CREATE_INFO ) * pCreateInfo,
      GR_PIPELINE * pPipeline );

   alias da_grClearDescriptorSetSlots = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet,
      GR_UINT startSlot,
      GR_UINT slotCount );

   alias da_grAttachMemoryViewDescriptors = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet,
      GR_UINT startSlot,
      GR_UINT slotCount,
      const( GR_MEMORY_VIEW_ATTACH_INFO ) * pMemViews );

   alias da_grWaitForFences = GR_RESULT function(
      GR_DEVICE device,
      GR_UINT fenceCount,
      const( GR_FENCE ) * pFences,
      GR_BOOL waitAll,
      GR_FLOAT timeout );

   alias da_grCreateImage = GR_RESULT function(
      GR_DEVICE device,
      const( GR_IMAGE_CREATE_INFO ) * pCreateInfo,
      GR_IMAGE * pImage );

   alias da_grDestroyObject = GR_RESULT function(
      GR_OBJECT object );

   alias da_grCreateImageView = GR_RESULT function(
      GR_DEVICE device,
      const( GR_IMAGE_VIEW_CREATE_INFO ) * pCreateInfo,
      GR_IMAGE_VIEW * pView );

   alias da_grAttachImageViewDescriptors = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet,
      GR_UINT startSlot,
      GR_UINT slotCount,
      const( GR_IMAGE_VIEW_ATTACH_INFO ) * pImageViews );

   alias da_grGetImageSubresourceInfo = GR_RESULT function(
      GR_IMAGE image,
      const( GR_IMAGE_SUBRESOURCE ) * pSubresource,
      GR_ENUM infoType,
      GR_SIZE * pDataSize,
      GR_VOID * pData );

   alias da_grResetCommandBuffer = GR_RESULT function(
      GR_CMD_BUFFER cmdBuffer );

   alias da_grCmdPrepareMemoryRegions = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_UINT transitionCount,
      const( GR_MEMORY_STATE_TRANSITION ) * pStateTransitions );

   alias da_grCmdCopyMemory = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_GPU_MEMORY srcMem,
      GR_GPU_MEMORY destMem,
      GR_UINT regionCount,
      const( GR_MEMORY_COPY ) * pRegions );

   alias da_grCmdCopyImage = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_IMAGE srcImage,
      GR_IMAGE destImage,
      GR_UINT regionCount,
      const( GR_IMAGE_COPY ) * pRegions );

   alias da_grCmdBindTargets = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_UINT colorTargetCount,
      const( GR_COLOR_TARGET_BIND_INFO ) * pColorTargets,
      const( GR_DEPTH_STENCIL_BIND_INFO ) * pDepthTarget );

   alias da_grCmdBindStateObject = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_ENUM stateBindPoint,
      GR_STATE_OBJECT state );

   alias da_grFreeMemory = GR_RESULT function(
      GR_GPU_MEMORY mem );

   alias da_grCmdCopyMemoryToImage = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_GPU_MEMORY srcMem,
      GR_IMAGE destImage,
      GR_UINT regionCount,
      const( GR_MEMORY_IMAGE_COPY ) * pRegions );

   alias da_grAttachNestedDescriptors = GR_VOID function(
      GR_DESCRIPTOR_SET descriptorSet,
      GR_UINT startSlot,
      GR_UINT slotCount,
      const( GR_DESCRIPTOR_SET_ATTACH_INFO ) * pNestedDescriptorSets );

   alias da_grCmdBindDescriptorSet = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_ENUM pipelineBindPoint,
      GR_UINT index,
      GR_DESCRIPTOR_SET descriptorSet,
      GR_UINT slotOffset );

   alias da_grCmdBindIndexData = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_GPU_MEMORY mem,
      GR_GPU_SIZE offset,
      GR_ENUM indexType );

   alias da_grCmdBindPipeline = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_ENUM pipelineBindPoint,
      GR_PIPELINE pipeline );

   alias da_grCmdDrawIndexed = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_UINT firstIndex,
      GR_UINT indexCount,
      GR_INT vertexOffset,
      GR_UINT firstInstance,
      GR_UINT instanceCount );

   alias da_grCmdBindDynamicMemoryView = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_ENUM pipelineBindPoint,
      const( GR_MEMORY_VIEW_ATTACH_INFO ) * pMemView );

   alias da_grCmdDispatch = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_UINT x,
      GR_UINT y,
      GR_UINT z );

   alias da_grCmdDraw = GR_VOID function(
      GR_CMD_BUFFER cmdBuffer,
      GR_UINT firstVertex,
      GR_UINT vertexCount,
      GR_UINT firstInstance,
      GR_UINT instanceCount );
}


__gshared  {
   da_grInitAndEnumerateGpus grInitAndEnumerateGpus;
   da_grGetGpuInfo grGetGpuInfo;
   da_grGetExtensionSupport grGetExtensionSupport;
   da_grCreateDevice grCreateDevice;
   da_grWsiWinGetDisplays grWsiWinGetDisplays;
   da_grWsiWinGetDisplayModeList grWsiWinGetDisplayModeList;
   da_grGetDeviceQueue grGetDeviceQueue;
   da_grWsiWinCreatePresentableImage grWsiWinCreatePresentableImage;
   da_grCreateCommandBuffer grCreateCommandBuffer;
   da_grBeginCommandBuffer grBeginCommandBuffer;
   da_grEndCommandBuffer grEndCommandBuffer;
   da_grQueueSubmit grQueueSubmit;
   da_grCmdPrepareImages grCmdPrepareImages;
   da_grCmdClearColorImage grCmdClearColorImage;
   da_grWsiWinQueuePresent grWsiWinQueuePresent;
   da_grDbgRegisterMsgCallback grDbgRegisterMsgCallback;
   da_grCreateViewportState grCreateViewportState;
   da_grGetMemoryHeapCount grGetMemoryHeapCount;
   da_grCreateColorTargetView grCreateColorTargetView;
   da_grGetMemoryHeapInfo grGetMemoryHeapInfo;
   da_grAllocMemory grAllocMemory;
   da_grCreateDescriptorSet grCreateDescriptorSet;
   da_grGetObjectInfo grGetObjectInfo;
   da_grBindObjectMemory grBindObjectMemory;
   da_grCreateFence grCreateFence;
   da_grCreateMsaaState grCreateMsaaState;
   da_grCreateSampler grCreateSampler;
   da_grBeginDescriptorSetUpdate grBeginDescriptorSetUpdate;
   da_grEndDescriptorSetUpdate grEndDescriptorSetUpdate;
   da_grAttachSamplerDescriptors grAttachSamplerDescriptors;
   da_grCreateColorBlendState grCreateColorBlendState;
   da_grCreateDepthStencilState grCreateDepthStencilState;
   da_grCreateRasterState grCreateRasterState;
   da_grMapMemory grMapMemory;
   da_grUnmapMemory grUnmapMemory;
   da_grCreateShader grCreateShader;
   da_grCreateGraphicsPipeline grCreateGraphicsPipeline;
   da_grCreateComputePipeline grCreateComputePipeline;
   da_grClearDescriptorSetSlots grClearDescriptorSetSlots;
   da_grAttachMemoryViewDescriptors grAttachMemoryViewDescriptors;
   da_grWaitForFences grWaitForFences;
   da_grCreateImage grCreateImage;
   da_grDestroyObject grDestroyObject;
   da_grCreateImageView grCreateImageView;
   da_grAttachImageViewDescriptors grAttachImageViewDescriptors;
   da_grGetImageSubresourceInfo grGetImageSubresourceInfo;
   da_grResetCommandBuffer grResetCommandBuffer;
   da_grCmdPrepareMemoryRegions grCmdPrepareMemoryRegions;
   da_grCmdCopyMemory grCmdCopyMemory;
   da_grCmdCopyImage grCmdCopyImage;
   da_grCmdBindTargets grCmdBindTargets;
   da_grCmdBindStateObject grCmdBindStateObject;
   da_grFreeMemory grFreeMemory;
   da_grCmdCopyMemoryToImage grCmdCopyMemoryToImage;
   da_grAttachNestedDescriptors grAttachNestedDescriptors;
   da_grCmdBindDescriptorSet grCmdBindDescriptorSet;
   da_grCmdBindIndexData grCmdBindIndexData;
   da_grCmdBindPipeline grCmdBindPipeline;
   da_grCmdDrawIndexed grCmdDrawIndexed;
   da_grCmdBindDynamicMemoryView grCmdBindDynamicMemoryView;
   da_grCmdDispatch grCmdDispatch;
   da_grCmdDraw grCmdDraw;
}

ShouldThrow missingSymbol( string symbol )  {
   return ShouldThrow.Yes;
}

class DerelictMantleLoader : SharedLibLoader {
   public this()  {
      super( libNames );
   }

   protected override void loadSymbols()  {
      bindFunc( cast( void ** ) & grInitAndEnumerateGpus , "grInitAndEnumerateGpus" );
      bindFunc( cast( void ** ) & grGetGpuInfo , "grGetGpuInfo" );
      bindFunc( cast( void ** ) & grGetExtensionSupport , "grGetExtensionSupport" );
      bindFunc( cast( void ** ) & grCreateDevice , "grCreateDevice" );
      bindFunc( cast( void ** ) & grWsiWinGetDisplays , "grWsiWinGetDisplays" );
      bindFunc( cast( void ** ) & grWsiWinGetDisplayModeList , "grWsiWinGetDisplayModeList" );
      bindFunc( cast( void ** ) & grGetDeviceQueue , "grGetDeviceQueue" );
      bindFunc( cast( void ** ) & grWsiWinCreatePresentableImage , "grWsiWinCreatePresentableImage" );
      bindFunc( cast( void ** ) & grCreateCommandBuffer , "grCreateCommandBuffer" );
      bindFunc( cast( void ** ) & grBeginCommandBuffer , "grBeginCommandBuffer" );
      bindFunc( cast( void ** ) & grEndCommandBuffer , "grEndCommandBuffer" );
      bindFunc( cast( void ** ) & grQueueSubmit , "grQueueSubmit" );
      bindFunc( cast( void ** ) & grCmdPrepareImages , "grCmdPrepareImages" );
      bindFunc( cast( void ** ) & grCmdClearColorImage , "grCmdClearColorImage" );
      bindFunc( cast( void ** ) & grWsiWinQueuePresent , "grWsiWinQueuePresent" );
      bindFunc( cast( void ** ) & grDbgRegisterMsgCallback , "grDbgRegisterMsgCallback" );
      bindFunc( cast( void ** ) & grCreateViewportState , "grCreateViewportState" );
      bindFunc( cast( void ** ) & grGetMemoryHeapCount , "grGetMemoryHeapCount" );
      bindFunc( cast( void ** ) & grCreateColorTargetView , "grCreateColorTargetView" );
      bindFunc( cast( void ** ) & grGetMemoryHeapInfo , "grGetMemoryHeapInfo" );
      bindFunc( cast( void ** ) & grAllocMemory , "grAllocMemory" );
      bindFunc( cast( void ** ) & grCreateDescriptorSet , "grCreateDescriptorSet" );
      bindFunc( cast( void ** ) & grGetObjectInfo , "grGetObjectInfo" );
      bindFunc( cast( void ** ) & grBindObjectMemory , "grBindObjectMemory" );
      bindFunc( cast( void ** ) & grCreateFence , "grCreateFence" );
      bindFunc( cast( void ** ) & grCreateMsaaState , "grCreateMsaaState" );
      bindFunc( cast( void ** ) & grCreateSampler , "grCreateSampler" );
      bindFunc( cast( void ** ) & grBeginDescriptorSetUpdate , "grBeginDescriptorSetUpdate" );
      bindFunc( cast( void ** ) & grEndDescriptorSetUpdate , "grEndDescriptorSetUpdate" );
      bindFunc( cast( void ** ) & grAttachSamplerDescriptors , "grAttachSamplerDescriptors" );
      bindFunc( cast( void ** ) & grCreateColorBlendState , "grCreateColorBlendState" );
      bindFunc( cast( void ** ) & grCreateDepthStencilState , "grCreateDepthStencilState" );
      bindFunc( cast( void ** ) & grCreateRasterState , "grCreateRasterState" );
      bindFunc( cast( void ** ) & grMapMemory , "grMapMemory" );
      bindFunc( cast( void ** ) & grUnmapMemory , "grUnmapMemory" );
      bindFunc( cast( void ** ) & grCreateShader , "grCreateShader" );
      bindFunc( cast( void ** ) & grCreateGraphicsPipeline , "grCreateGraphicsPipeline" );
      bindFunc( cast( void ** ) & grCreateComputePipeline , "grCreateComputePipeline" );
      bindFunc( cast( void ** ) & grClearDescriptorSetSlots , "grClearDescriptorSetSlots" );
      bindFunc( cast( void ** ) & grAttachMemoryViewDescriptors , "grAttachMemoryViewDescriptors" );
      bindFunc( cast( void ** ) & grWaitForFences , "grWaitForFences" );
      bindFunc( cast( void ** ) & grCreateImage , "grCreateImage" );
      bindFunc( cast( void ** ) & grDestroyObject , "grDestroyObject" );
      bindFunc( cast( void ** ) & grCreateImageView , "grCreateImageView" );
      bindFunc( cast( void ** ) & grAttachImageViewDescriptors , "grAttachImageViewDescriptors" );
      bindFunc( cast( void ** ) & grGetImageSubresourceInfo , "grGetImageSubresourceInfo" );
      bindFunc( cast( void ** ) & grResetCommandBuffer , "grResetCommandBuffer" );
      bindFunc( cast( void ** ) & grCmdPrepareMemoryRegions , "grCmdPrepareMemoryRegions" );
      bindFunc( cast( void ** ) & grCmdCopyMemory , "grCmdCopyMemory" );
      bindFunc( cast( void ** ) & grCmdCopyImage , "grCmdCopyImage" );
      bindFunc( cast( void ** ) & grCmdBindTargets , "grCmdBindTargets" );
      bindFunc( cast( void ** ) & grCmdBindStateObject , "grCmdBindStateObject" );
      bindFunc( cast( void ** ) & grFreeMemory , "grFreeMemory" );
      bindFunc( cast( void ** ) & grCmdCopyMemoryToImage , "grCmdCopyMemoryToImage" );
      bindFunc( cast( void ** ) & grAttachNestedDescriptors , "grAttachNestedDescriptors" );
      bindFunc( cast( void ** ) & grCmdBindDescriptorSet , "grCmdBindDescriptorSet" );
      bindFunc( cast( void ** ) & grCmdBindIndexData , "grCmdBindIndexData" );
      bindFunc( cast( void ** ) & grCmdBindPipeline , "grCmdBindPipeline" );
      bindFunc( cast( void ** ) & grCmdDrawIndexed , "grCmdDrawIndexed" );
      bindFunc( cast( void ** ) & grCmdBindDynamicMemoryView , "grCmdBindDynamicMemoryView" );
      bindFunc( cast( void ** ) & grCmdDispatch , "grCmdDispatch" );
      bindFunc( cast( void ** ) & grCmdDraw , "grCmdDraw" );
   }
}

__gshared DerelictMantleLoader DerelictMantle;

shared static this()  {
    DerelictMantle = new DerelictMantleLoader();
    DerelictMantle.missingSymbolCallback( & missingSymbol );
}
